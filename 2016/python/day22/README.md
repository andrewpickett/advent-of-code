# Approach
### Data format

I read each line of input into an object with all of the attributes defined. I then take all of those and set them as the
value of points in my `Grid` class. So the end result is a full grid of each of the nodes defined. The objects that are
the values of the points look something like this:
```
{
	"x": 0,
	"y": 0,
	"size": 6,
	"used": 3,
	"avail": 3,
	"usepercent": 50
}
```

### Part 1
> _How many viable pairs of nodes are there?_

For this part, I just iterate over every point and compare with every other point in the grid. If the used amount
is less than the available amount of another node, then we just add that pair to an array. In the end, we have an
array of all viable pairs, so we just need to return the length.

### Part 2
> __

Yeah...ok...so, it took me WAY too long to even decipher what the heck was being asked and even once I kind of understood
it, I had no idea what it was expecting.

After a long time of looking at the example and reading it over and over, I thought it sounded a lot like one of those
sliding tile puzzle games. Basically you have one empty node and you need to move data in/around that empty node in order
to move the empty node to where you want.

Ok...But what about the "too large, too full" nodes? Well, I thought of those as "unmoveable" tiles. So in other words
you can't cycle or swap with them and you have to go "around them" when moving your empty node.

Great...but I have no idea how to code that up easily. I decided I would just output the grid, similar to what they
showed in the example. I said if a node is over 95% full, I'd mark it as a `#`, if it's empty, I'd mark it as `_`, and
everything else would be `.`. I then marked my starting node with `S` and my ending node with `G`. It output a pretty
map with one giant wall in the middle of it. Something like this:

```
S..............................
....................#..........
....................#..........
....................#......._..
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
....................#..........
G...................#..........
```

Knowing what the idea was, I decided to just try to manually figure out the theoretical minimum for moving the data...

So the first "step" is to move the "empty" node to my goal location. To do that, I had to move up and over the giant
wall, and it took `63` moves to get from the `_` to the `G` in my graph above. Great. Now I need to actually swap the data,
using that empty node, to move the data from `G` to `S`. In doing some trial and error, I found that each swap to move it up
takes 5 moves of the data. So that would mean to move from `G` to `S`, which is 31 spaces away, it would take `31 x 5 = 155`
moves. Add the `155` to the `63` that it took to move the empty node and I got `218` -- I decided to just try entering that
and see what would happen...and to my great surprise, it worked!

Now I do want to go back and actually CODE this if I can, but for now, I'm going to leave it as it is.


# Results

|              | Exec. Time (ms) |
|--------------|----------------:|
| **Part One** |             410 |
| **Part Two** |              <1 |
